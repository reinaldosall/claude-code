# SuperClaude 행동 모드 가이드 🧠

## ✅ 빠른 확인
`/sc:` 명령어를 사용하여 모드를 테스트하세요 - 작업 복잡성에 따라 자동으로 활성화됩니다. 전체 명령어 참조는 [명령어 가이드](commands.md)를 참조하세요.

## 빠른 참조 표

| 모드 | 목적 | 자동 트리거 | 주요 동작 | 최적 사용처 |
|------|---------|---------------|---------------|---------------|
| **🧠 브레인스토밍** | 대화형 발견 | "brainstorm", "maybe", 모호한 요청 | 소크라테스식 질문, 요구사항 도출 | 새 프로젝트 계획, 불명확한 요구사항 |
| **🔍 내성** | 메타인지 분석 | 오류 복구, "추론 분석" | 투명한 사고 마커 (🤔, 🎯, 💡) | 디버깅, 학습, 최적화 |
| **🔬 심층 연구** | 체계적 조사 마인드셋 | `/sc:research`, 조사 키워드 | 6단계 워크플로우, 증거 기반 추론 | 기술 연구, 최신 이벤트, 시장 분석 |
| **📋 작업 관리** | 복잡한 조정 | >3단계, >2개 디렉토리 | 단계 분해, 메모리 지속성 | 다단계 작업, 프로젝트 관리 |
| **🎯 오케스트레이션** | 지능형 도구 선택 | 다중 도구 작업, 높은 리소스 사용 | 최적의 도구 라우팅, 병렬 실행 | 복잡한 분석, 성능 최적화 |
| **⚡ 토큰 효율성** | 압축 커뮤니케이션 | 높은 컨텍스트 사용, `--uc` 플래그 | 심볼 시스템, 예상 30-50% 토큰 감소 | 리소스 제약, 대규모 작업 |

---

## 시작하기 (2분 개요)

**모드는 행동 지침을 통해 활성화됩니다** - Claude Code가 컨텍스트 파일을 읽어 작업 패턴과 복잡성에 따라 채택할 모드 동작을 결정합니다.

**빠른 예제:**
```bash
# 자동 활성화 예제
/sc:brainstorm "모바일 앱"        # → 소크라테스식 발견 질문
/sc:implement "인증 시스템"        # → 다단계 조정
"--uc analyze large-codebase/"     # → 압축된 심볼 출력
```

**수동 플래그를 사용할 때:**
- 특정 동작 필요: `--brainstorm`, `--introspect`, `--uc`
- 학습/디버깅을 위한 자동 감지 재정의
- 특정 제약(메모리, 시간, 명확성)에 최적화

---

## 모드 세부정보

### 🧠 브레인스토밍 모드 - 대화형 발견

**목적**: 협업 발견을 통해 모호한 아이디어를 구조화된 요구사항으로 변환합니다.

**자동 활성화 트리거:**
- 모호한 프로젝트 요청: "만들고 싶어...", "생각하고 있는데..."
- 탐색 키워드: brainstorm, explore, discuss, figure out, not sure
- 불확실성 지표: "maybe", "possibly", "could we"
- 수동 플래그: `--brainstorm`, `--bs`

**행동 변화:**
- **소크라테스식 질문**: 숨겨진 요구사항을 찾기 위한 탐색 질문
- **비가정적 접근**: 가정을 피하고 발견 방향을 안내하도록 함
- **협업 파트너십**: 지시적 컨설팅이 아닌 탐색에서 함께 작업
- **요구사항 종합**: 통찰력을 구조화된 기술 브리프로 변환
- **교차 세션 메모리**: 후속 토론을 위한 발견 컨텍스트 유지

**예제 경험:**
```
표준 접근법: "JWT 토큰으로 사용자 인증 시스템을 구축하겠습니다..."
브레인스토밍 접근법:
"🤔 함께 탐색해봅시다:
 - 인증이 앱에서 해결하는 특정 사용자 문제는 무엇인가요?
 - 사용자는 누구이며 기술적 편안함 수준은 어떤가요?
 - 통합할 기존 시스템이나 소셜 로그인이 있나요?
 - 어떤 보안/규정 준수 요구사항이 있나요?
 📝 결과: 구현 준비가 된 상세한 인증 요구사항 브리프"
```

#### 성공 기준
- [ ] 즉각적인 솔루션 대신 질문으로 응답
- [ ] 질문이 사용자 요구, 기술 제약, 비즈니스 목표 탐색
- [ ] 발견 과정 전반에 걸쳐 협업적 어조 유지
- [ ] 결과로 구조화된 요구사항 또는 기술 브리프 생성

**검증:** `/sc:brainstorm "웹 앱"`은 사용자, 기능, 기술에 대해 질문해야 함
**테스트:** 모호한 요청은 가정이 아닌 발견 질문을 트리거해야 함
**확인:** 동일한 대화에서 후속 질문 전반에 걸쳐 모드가 지속되어야 함

**최적의 협업 대상:**
- **→ 작업 관리**: 요구사항 발견 → 체계적인 구현 계획
- **→ 오케스트레이션**: 요구사항 명확성 → 구현을 위한 최적의 도구 선택
- **수동 재정의**: "명확한" 요구사항에도 발견을 강제하려면 `--brainstorm` 사용

---

### 🔍 내성 모드 - 메타인지 분석

**목적**: 학습 최적화 및 투명한 의사결정을 위한 추론 과정 노출

**자동 활성화 트리거:**
- 자기 분석 요청: "내 추론 분석", "결정 성찰"
- 조사가 필요한 오류 복구 시나리오 및 예상치 못한 결과
- 여러 가능한 접근법이 있는 복잡한 문제 해결
- 최적화 기회를 위한 패턴 인식 필요
- 수동 플래그: `--introspect`

**행동 변화:**
- **추론 투명성**: 명확한 마커로 사고 과정 노출 (🤔, 🎯, ⚡, 📊, 💡)
- **결정 분석**: 선택 논리 평가 및 대안 접근법 고려
- **패턴 인식**: 반복되는 행동 및 개선 기회 식별
- **메타 학습**: 지속적인 프레임워크 개선을 위한 통찰력 추출
- **프레임워크 규정 준수**: SuperClaude 원칙 및 품질 게이트에 대한 행동 검증

**예제 경험:**
```
표준 접근법: "이 코드 구조를 분석하고 개선 사항을 제안하겠습니다..."
내성적 접근법:
"🧠 메타 분석: 왜 기능 흐름보다 구조적 분석을 선택했을까?
 🎯 결정 논리: 클래스 계층 구조 확인 → OOP 패턴 우세 가정
 🔄 고려된 대안: 데이터 흐름 분석이 숨겨진 종속성 드러낼 수 있음
 📊 증거 확인: 파일 임포트가 OOP가 아닌 함수형 구성 시사
 💡 학습: 분석 전략 선택 전에 임포트 분석 필요
 ⚡ 수정: 함수형 흐름 분석 접근법으로 전환"
```

**최적의 협업 대상:**
- **→ 작업 관리**: 복잡한 단계 결정에 대한 투명한 추론 제공
- **모든 모드**: 다른 모드의 작업에 추론 투명성 레이어 추가
- **수동 재정의**: 학습 세션 및 디버깅 워크플로우에 `--introspect` 사용

---

### 🔬 심층 연구 모드 - 체계적 조사 마인드셋

**목적**: 체계적 조사 및 증거 기반 추론을 위한 연구 마인드셋

**자동 활성화 트리거:**
- `/sc:research` 명령어 호출
- 연구 관련 키워드: investigate, explore, discover, analyze
- 지식 컷오프를 넘어선 최신 정보가 필요한 질문
- 복잡한 연구 요구사항
- 수동 플래그: `--research`

**행동 수정:**
- **사고 스타일**: 캐주얼보다 체계적, 가정보다 증거, 점진적 깊이 탐색
- **커뮤니케이션**: 신뢰 수준으로 시작, 인라인 인용 제공, 불확실성 인정
- **우선순위 전환**: 속도보다 완전성, 추측보다 정확성, 가정보다 검증
- **프로세스 적응**: 항상 조사 계획 생성, 병렬 작업 기본값, 증거 체인 유지

**6단계 연구 워크플로우:**
- 📋 **이해** (5-10%): 쿼리 복잡성 및 요구사항 평가
- 📝 **계획** (10-15%): 전략 선택 (planning/intent/unified) 및 병렬화 식별
- ✅ **TodoWrite** (5%): 복잡성에 따라 적응형 작업 계층 구조 생성 (3-15개 작업)
- 🔄 **실행** (50-60%): 병렬 우선 검색 및 스마트 추출 라우팅
- 📊 **추적** (지속적): 진행 상황 모니터링 및 신뢰도 점수 업데이트
- ✓ **검증** (10-15%): 증거 체인 확인 및 완전성 보장

**예제 경험:**
```
표준 모드: "양자 컴퓨팅에 대한 검색 결과입니다..."
심층 연구 모드:
"📊 연구 계획: 양자 컴퓨팅 돌파구
 ✓ TodoWrite: 8개 연구 작업 생성
 🔄 도메인 전반에 걸쳐 병렬 검색 실행
 📈 신뢰도: 15개 검증된 소스에서 0.82
 📝 보고서 저장됨: claudedocs/research_quantum_[timestamp].md"
```

#### 품질 표준
- [ ] 인라인 인용이 있는 주장당 최소 2개 소스
- [ ] 모든 발견에 대한 신뢰도 점수 (0.0-1.0)
- [ ] 독립적인 작업에 대한 병렬 실행 기본값
- [ ] 적절한 구조로 claudedocs/에 보고서 저장
- [ ] 명확한 방법론 및 증거 제시

**검증:** `/sc:research "테스트 주제"`는 TodoWrite를 생성하고 체계적으로 실행해야 함
**테스트:** 모든 연구에 신뢰도 점수 및 인용이 포함되어야 함
**확인:** 보고서가 자동으로 claudedocs/에 저장되어야 함

**최적의 협업 대상:**
- **→ 작업 관리**: TodoWrite 통합을 통한 연구 계획
- **→ 오케스트레이션**: 병렬 Tavily/Playwright 조정
- **수동 재정의**: 세밀한 제어를 위해 `--depth` 및 `--strategy` 사용

---

### 📋 작업 관리 모드 - 복잡한 조정

**목적**: 다단계 작업을 위한 세션 지속성을 갖춘 계층적 작업 조직

**자동 활성화 트리거:**
- >3개의 조정된 단계가 필요한 작업
- 다중 파일/디렉토리 범위 (>2개 디렉토리 또는 >3개 파일)
- 단계 및 체크포인트가 필요한 복잡한 종속성
- 품질 개선 요청: polish, refine, enhance
- 수동 플래그: `--task-manage`, `--delegate`

**행동 변화:**
- **계층적 계획**: 복잡한 작업을 Plan → Phase → Task → Todo 구조로 분해
- **세션 지속성**: 중단 전반에 걸쳐 프로젝트 컨텍스트 및 진행 상황 유지
- **메모리 통합**: 상태 보존을 위해 write_memory/read_memory 사용
- **진행 오케스트레이션**: 추적을 위해 TodoWrite와 메모리 업데이트 조정
- **품질 게이트**: 단계 간 체계적인 검증 체크포인트 구현

**예제 경험:**
```
표준 접근법: "사용자 인증을 구현하겠습니다..." → 직접 구현
작업 관리 접근법:
"📋 다단계 구현 계획:
 🎯 1단계: 보안 요구사항 분석 (세션 1)
 🎯 2단계: API 설계 및 문서화 (세션 2)
 🎯 3단계: 구현 및 테스팅 (세션 3-4)
 🎯 4단계: 통합 및 검증 (세션 5)
 💾 세션 지속성: 자동으로 컨텍스트 재개
 ✓ 품질 게이트: 각 단계 전환 전 검증"
```

**최적의 협업 대상:**
- **브레인스토밍 →**: 요구사항 발견 후 체계적인 구현
- **+ 오케스트레이션**: 최적의 도구 선택을 통한 작업 조정
- **+ 내성**: 복잡한 단계 결정에 대한 투명한 추론

---

### 🎯 오케스트레이션 모드 - 지능형 도구 선택

**목적**: 지능형 도구 라우팅 및 병렬 조정을 통한 작업 실행 최적화

**자동 활성화 트리거:**
- 정교한 조정이 필요한 다중 도구 작업
- 성능 제약 (높은 리소스 사용)
- 병렬 실행 기회 (>3개 독립적 파일/작업)
- 여러 유효한 도구 접근법이 있는 복잡한 라우팅 결정

**행동 변화:**
- **지능형 도구 라우팅**: 각 작업 유형에 최적의 MCP 서버 및 네이티브 도구 선택
- **리소스 인식**: 시스템 제약 및 가용성에 따라 접근법 조정
- **병렬 최적화**: 동시 실행을 위한 독립적인 작업 식별
- **조정 초점**: 조정된 실행을 통한 도구 선택 및 사용 최적화
- **적응형 폴백**: 선호하는 옵션을 사용할 수 없을 때 도구를 우아하게 전환

**예제 경험:**
```
표준 접근법: 순차적 파일별 분석 및 편집
오케스트레이션 접근법:
"🎯 다중 도구 조정 전략:
 🔍 1단계: Serena (의미론적 분석) + Sequential (아키텍처 검토)
 ⚡ 2단계: Morphllm (패턴 편집) + Magic (UI 컴포넌트)
 🧪 3단계: Playwright (테스팅) + Context7 (문서 패턴)
 🔄 병렬 실행: 3개 도구 동시 작업"
```

**최적의 협업 대상:**
- **작업 관리 →**: 복잡한 다단계 계획을 위한 도구 조정 제공
- **+ 토큰 효율성**: 압축 커뮤니케이션을 통한 최적의 도구 선택
- **모든 복잡한 작업**: 실행을 향상시키기 위한 지능형 도구 라우팅 추가

---

### ⚡ 토큰 효율성 모드 - 압축 커뮤니케이션

**목적**: 정보 품질을 유지하면서 심볼 시스템을 통해 예상 30-50% 토큰 감소 달성

**자동 활성화 트리거:**
- 제한에 근접한 높은 컨텍스트 사용
- 리소스 효율성이 필요한 대규모 작업
- 사용자 명시적 플래그: `--uc`, `--ultracompressed`
- 여러 출력이 있는 복잡한 분석 워크플로우

**행동 변화:**
- **심볼 커뮤니케이션**: 논리 흐름, 상태, 기술 도메인을 위한 시각적 심볼 사용
- **기술 약어**: 반복되는 기술 용어에 대한 컨텍스트 인식 압축
- **구조화된 밀도**: 장황한 단락보다 글머리 기호, 표, 간결한 형식
- **정보 보존**: 압축에도 불구하고 ≥95% 정보 품질 유지
- **구조화된 형식**: 명확성 및 작업 완료를 위해 조직화

**예제 경험:**
```
표준 접근법: "인증 시스템 구현은 즉각적인 주의가 필요한 사용자 검증 함수의 보안 취약점을 보여줍니다..."
토큰 효율적 접근법:
"🛡️ 보안 경고:
 auth.js:45 → user val() → 중요한 취약점
 📊 영향: ❌ 토큰 우회 가능
 ⚡ 조치: 검증 수정 + 감사 ∵ 높은 심각도
 🔧 예상: 2시간 구현 + 1시간 테스트"
```

**최적의 협업 대상:**
- **모든 모드**: 모드별 동작을 유지하면서 압축 레이어 추가
- **오케스트레이션 →**: 압축된 도구 조정 및 상태 업데이트
- **수동 재정의**: 컨텍스트 압박 또는 효율성이 우선순위일 때 `--uc` 사용

---

### 🎨 표준 모드 - 균형 잡힌 기본값

**목적**: 간단한 개발 작업을 위한 명확하고 전문적인 커뮤니케이션 제공

**자동 활성화 트리거:**
- 복잡성 지표가 없는 간단하고 잘 정의된 작업
- 명확한 요구사항이 있는 단일 파일 작업
- 기본 설명 및 표준 개발 워크플로우
- 다른 모드 트리거가 감지되지 않음 (기본 폴백)

**행동 변화:**
- **전문적 커뮤니케이션**: 압축 없이 명확하고 간결한 기술 언어
- **적당한 세부사항**: 대부분의 개발 작업에 적합한 균형 잡힌 정보 깊이
- **표준 도구 선택**: 네이티브 Claude 기능 및 기본 도구 사용
- **품질 초점**: 복잡한 오케스트레이션 오버헤드 없이 코드 품질 유지
- **반응형 적응**: 복잡성이 증가할 때 전문 모드로 전환할 준비

**예제 경험:**
```
표준 접근법: 모든 작업에 대한 일관되고 전문적인 기준선
"적절한 오류 처리와 함께 로그인 함수를 구현하겠습니다:
 
 1. 사용자 입력 검증 (이메일 형식, 비밀번호 요구사항)
 2. 안전한 해싱으로 데이터베이스에 대해 인증
 3. 적절한 만료를 갖춘 JWT 토큰 생성
 4. 사용자 데이터와 함께 성공 응답 반환
 
 구현은 보안 모범 사례를 따르고 포괄적인 오류 처리를 포함할 것입니다."
```

**최적의 협업 대상:**
- **→ 모든 모드**: 다른 모드가 향상시키는 기준선 역할
- **모드 전환**: 필요할 때 자동으로 전문 모드로 확장
- **명확성 우선순위**: 간단한 커뮤니케이션이 최적화보다 중요할 때

---

## 고급 사용

### 모드 조합

**다중 모드 워크플로우:**
```bash
# 발견 → 계획 → 구현
/sc:brainstorm "마이크로서비스 아키텍처" --task-manage
# → 브레인스토밍: 요구사항 발견
# → 작업 관리: 다단계 조정

# 투명성 및 효율성을 갖춘 분석
/sc:analyze legacy-system/ --introspect --uc
# → 내성: 투명한 추론
# → 토큰 효율성: 압축된 출력
```

### 수동 모드 제어

**특정 동작 강제:**
- `--brainstorm`: 모든 작업에 대한 협업 발견 강제
- `--introspect`: 모든 모드에 추론 투명성 추가
- `--task-manage`: 계층적 조정 활성화
- `--orchestrate`: 도구 선택 및 병렬 실행 최적화
- `--uc`: 효율성을 위해 커뮤니케이션 압축

**재정의 예제:**
```bash
# "명확한" 요구사항에 브레인스토밍 강제
/sc:implement "사용자 로그인" --brainstorm

# 디버깅에 추론 투명성 추가
# 투명한 추론으로 인증 문제 디버그

# 간단한 작업에 작업 관리 활성화
# 체계적인 작업 관리로 styles.css 업데이트
```

### 모드 경계 및 우선순위

**모드가 활성화되는 시점:**
1. **복잡성 임계값**: >3개 파일 → 작업 관리
2. **리소스 압박**: 높은 컨텍스트 사용 → 토큰 효율성
3. **다중 도구 필요**: 복잡한 분석 → 오케스트레이션
4. **불확실성**: 모호한 요구사항 → 브레인스토밍
5. **오류 복구**: 문제 → 내성

**우선순위 규칙:**
- **안전 우선**: 품질 및 검증이 항상 효율성 재정의
- **사용자 의도**: 수동 플래그가 자동 감지 재정의
- **컨텍스트 적응**: 모드가 복잡성에 따라 스택됨
- **리소스 관리**: 압박 하에서 효율성 모드 활성화

---

## 실제 예제

### 완전한 워크플로우 예제

**새 프로젝트 개발:**
```bash
# 1단계: 발견 (브레인스토밍 모드 자동 활성화)
"생산성 앱을 만들고 싶어요"
→ 🤔 사용자, 기능, 플랫폼 선택에 대한 소크라테스식 질문
→ 📝 구조화된 요구사항 브리프

# 2단계: 계획 (작업 관리 모드 자동 활성화)
/sc:implement "핵심 생산성 기능"
→ 📋 종속성이 있는 다단계 분해
→ 🎯 품질 게이트를 갖춘 단계 조정

# 3단계: 구현 (오케스트레이션 모드가 도구 조정)
/sc:implement "프론트엔드 및 백엔드 시스템"
→ 🎯 Magic (UI) + Context7 (패턴) + Sequential (아키텍처)
→ ⚡ 병렬 실행 최적화
```

**복잡한 문제 디버깅:**
```bash
# 문제 분석 (내성 모드 자동 활성화)
"사용자가 간헐적인 인증 실패를 겪고 있어요"
→ 🤔 잠재적 원인에 대한 투명한 추론
→ 🎯 가설 형성 및 증거 수집
→ 💡 유사한 문제 전반의 패턴 인식

# 체계적 해결 (작업 관리가 조정)
# 인증 시스템 포괄적으로 수정
→ 📋 1단계: 근본 원인 분석
→ 📋 2단계: 솔루션 구현
→ 📋 3단계: 테스팅 및 검증
```

### 모드 조합 패턴

**높은 복잡성 시나리오:**
```bash
# 여러 제약이 있는 대규모 리팩토링
/sc:improve legacy-system/ --introspect --uc --orchestrate
→ 🔍 투명한 추론 (내성)
→ ⚡ 압축 커뮤니케이션 (토큰 효율성)
→ 🎯 최적의 도구 조정 (오케스트레이션)
→ 📋 체계적 단계 (작업 관리 자동 활성화)
```

---

## 빠른 참조

### 모드 활성화 패턴

| 트리거 유형 | 예제 입력 | 활성화된 모드 | 주요 동작 |
|--------------|---------------|----------------|--------------|
| **모호한 요청** | "앱을 만들고 싶어요" | 🧠 브레인스토밍 | 소크라테스식 발견 질문 |
| **복잡한 범위** | >3개 파일 또는 >2개 디렉토리 | 📋 작업 관리 | 단계 조정 |
| **다중 도구 필요** | 분석 + 구현 | 🎯 오케스트레이션 | 도구 최적화 |
| **오류 복구** | "예상대로 작동하지 않아요" | 🔍 내성 | 투명한 추론 |
| **리소스 압박** | 높은 컨텍스트 사용 | ⚡ 토큰 효율성 | 심볼 압축 |
| **간단한 작업** | "이 함수 수정" | 🎨 표준 | 명확하고 직접적인 접근 |

### 수동 재정의 명령어

```bash
# 특정 모드 동작 강제
/sc:command --brainstorm    # 협업 발견
/sc:command --introspect    # 추론 투명성
/sc:command --task-manage   # 계층적 조정
/sc:command --orchestrate   # 도구 최적화
/sc:command --uc           # 토큰 압축

# 여러 모드 결합
/sc:command --introspect --uc    # 투명 + 효율적
/sc:command --task-manage --orchestrate  # 조정 + 최적화
```

---

## 문제 해결

문제 해결 도움말은 다음을 참조하세요:
- [일반적인 문제](../Reference/common-issues.md) - 자주 발생하는 문제에 대한 빠른 수정
- [문제 해결 가이드](../Reference/troubleshooting.md) - 포괄적인 문제 해결

### 일반적인 문제
- **모드가 활성화되지 않음**: 수동 플래그 사용: `--brainstorm`, `--introspect`, `--uc`
- **잘못된 모드 활성화**: 요청의 복잡성 트리거 및 키워드 확인
- **모드가 예기치 않게 전환됨**: 작업 진화에 따른 정상적인 동작
- **실행 영향**: 모드는 도구 사용 최적화, 실행에 영향을 주지 않아야 함
- **모드 충돌**: [플래그 가이드](flags.md)의 플래그 우선순위 규칙 확인

### 즉각적인 수정
- **특정 모드 강제**: `--brainstorm` 또는 `--task-manage`와 같은 명시적 플래그 사용
- **모드 동작 재설정**: 모드 상태를 재설정하려면 Claude Code 세션 재시작
- **모드 지표 확인**: 응답에서 🤔, 🎯, 📋 심볼 찾기
- **복잡성 확인**: 간단한 작업은 표준 모드 사용, 복잡한 작업은 자동 전환

### 모드별 문제 해결

**브레인스토밍 모드 문제:**
```bash
# 문제: 모드가 질문 대신 솔루션 제공
# 빠른 수정: 요청 명확성 확인 및 명시적 플래그 사용
/sc:brainstorm "웹 앱" --brainstorm         # 발견 모드 강제
"...에 대한 모호한 아이디어가 있어요"        # 불확실성 언어 사용
"...를 구축할 수 있을까요"                   # 탐색 트리거
```

**작업 관리 모드 문제:**
```bash
# 문제: 간단한 작업이 복잡한 조정을 받음
# 빠른 수정: 범위 줄이기 또는 더 간단한 명령어 사용
/sc:implement "함수" --no-task-manage     # 조정 비활성화
/sc:troubleshoot bug.js                   # 기본 명령어 사용
# 작업이 정말 복잡한지 확인 (>3개 파일, >2개 디렉토리)
```

**토큰 효율성 모드 문제:**
```bash
# 문제: 출력이 너무 압축되거나 불명확함
# 빠른 수정: 명확성을 위해 압축 비활성화
/sc:command --no-uc                           # 압축 비활성화
/sc:command --verbose                         # 상세 출력 강제
# 명확성이 효율성보다 중요할 때 사용
```

**내성 모드 문제:**
```bash
# 문제: 너무 많은 메타 주석, 충분한 행동 없음
# 빠른 수정: 직접 작업을 위해 내성 비활성화
/sc:command --no-introspect                   # 직접 실행
# 학습 및 디버깅에만 내성 사용
```

**오케스트레이션 모드 문제:**
```bash
# 문제: 도구 조정이 혼란 야기
# 빠른 수정: 도구 사용 단순화
/sc:command --no-mcp                          # 네이티브 도구만
/sc:command --simple                          # 기본 실행
# 작업 복잡성이 오케스트레이션을 정당화하는지 확인
```

### 오류 코드 참조

| 모드 오류 | 의미 | 빠른 수정 |
|------------|---------|-----------|
| **B001** | 브레인스토밍 활성화 실패 | 명시적 `--brainstorm` 플래그 사용 |
| **T001** | 작업 관리 오버헤드 | 간단한 작업에 `--no-task-manage` 사용 |
| **U001** | 토큰 효율성이 너무 공격적 | `--verbose` 또는 `--no-uc` 사용 |
| **I001** | 내성 모드 정체 | 직접 행동을 위해 `--no-introspect` 사용 |
| **O001** | 오케스트레이션 조정 실패 | `--no-mcp` 또는 `--simple` 사용 |
| **M001** | 모드 충돌 감지 | 플래그 우선순위 규칙 확인 |
| **M002** | 모드 전환 루프 | 상태를 재설정하려면 세션 재시작 |
| **M003** | 모드를 인식할 수 없음 | SuperClaude 업데이트 또는 철자 확인 |

### 점진적 지원 수준

**수준 1: 빠른 수정 (< 2분)**
- 자동 모드 선택을 재정의하려면 수동 플래그 사용
- 작업 복잡성이 예상 모드 동작과 일치하는지 확인
- Claude Code 세션 재시작 시도

**수준 2: 상세 도움말 (5-15분)**
```bash
# 모드별 진단
/sc:help modes                            # 사용 가능한 모든 모드 나열
/sc:reflect --type mode-status            # 현재 모드 상태 확인
# 요청 복잡성 및 트리거 검토
```
- 모드 설치 문제는 [일반적인 문제 가이드](../Reference/common-issues.md) 참조

**수준 3: 전문가 지원 (30분 이상)**
```bash
# 심층 모드 분석
SuperClaude install --diagnose
# 모드 활성화 패턴 확인
# 행동 트리거 및 임계값 검토
```
- 행동 모드 분석은 [진단 참조 가이드](../Reference/diagnostic-reference.md) 참조

**수준 4: 커뮤니티 지원**
- [GitHub Issues](https://github.com/SuperClaude-Org/SuperClaude_Framework/issues)에서 모드 문제 보고
- 예상치 못한 모드 동작 예제 포함
- 원하는 모드 활성화 vs 실제 모드 활성화 설명

### 성공 검증

모드 수정 적용 후 다음으로 테스트:
- [ ] 간단한 요청은 표준 모드 사용 (명확하고 직접적인 응답)
- [ ] 복잡한 요청은 적절한 모드 자동 활성화 (조정, 추론)
- [ ] 수동 플래그가 자동 감지를 올바르게 재정의
- [ ] 예상될 때 모드 지표 (🤔, 🎯, 📋) 나타남
- [ ] 다양한 모드 전반에 걸쳐 성능이 양호하게 유지됨

## 빠른 문제 해결 (레거시)
- **모드가 활성화되지 않음** → 수동 플래그 사용: `--brainstorm`, `--introspect`, `--uc`
- **잘못된 모드 활성화** → 요청의 복잡성 트리거 및 키워드 확인
- **모드가 예기치 않게 전환됨** → 작업 진화에 따른 정상적인 동작
- **실행 영향** → 모드는 도구 사용 최적화, 실행에 영향을 주지 않아야 함
- **모드 충돌** → [플래그 가이드](flags.md)의 플래그 우선순위 규칙 확인

## 자주 묻는 질문

**Q: 어떤 모드가 활성화되어 있는지 어떻게 알 수 있나요?**
A: 커뮤니케이션 패턴에서 이러한 지표를 찾으세요:
- 🤔 발견 질문 → 브레인스토밍
- 🎯 추론 투명성 → 내성
- 단계 분해 → 작업 관리
- 도구 조정 → 오케스트레이션
- 심볼 압축 → 토큰 효율성

**Q: 특정 모드를 강제할 수 있나요?**
A: 예, 자동 감지를 재정의하려면 수동 플래그 사용:
```bash
/sc:command --brainstorm     # 발견 강제
/sc:command --introspect     # 투명성 추가
/sc:command --task-manage    # 조정 활성화
/sc:command --uc            # 출력 압축
```

**Q: 모드가 실행에 영향을 미치나요?**
A: 모드는 조정을 통해 도구 사용 최적화:
- **토큰 효율성**: 30-50% 컨텍스트 감소
- **오케스트레이션**: 병렬 처리
- **작업 관리**: 체계적인 계획을 통한 재작업 방지

**Q: 모드가 함께 작동할 수 있나요?**
A: 예, 모드는 서로를 보완하도록 설계됨:
- **작업 관리**가 다른 모드 조정
- **토큰 효율성**이 모든 모드의 출력 압축
- **내성**이 모든 워크플로우에 투명성 추가

---

## 요약

SuperClaude의 5가지 행동 모드는 필요에 따라 자동으로 일치하는 **지능형 적응 시스템**을 만듭니다:

- **🧠 브레인스토밍**: 모호한 아이디어를 명확한 요구사항으로 변환
- **🔍 내성**: 학습 및 디버깅을 위한 투명한 추론 제공
- **📋 작업 관리**: 복잡한 다단계 작업 조정
- **🎯 오케스트레이션**: 도구 선택 및 병렬 실행 최적화
- **⚡ 토큰 효율성**: 명확성을 유지하면서 커뮤니케이션 압축
- **🎨 표준**: 간단한 작업을 위한 전문적 기준선 유지

**핵심 인사이트**: 모드에 대해 생각할 필요가 없습니다 - 개발 경험을 향상시키기 위해 투명하게 작동합니다. 달성하고자 하는 것을 설명하면 SuperClaude가 자동으로 필요에 맞게 접근 방식을 조정합니다.

---

## 관련 가이드

**학습 진행:**

**🌱 필수 (1주차)**
- [빠른 시작 가이드](../Getting-Started/quick-start.md) - 모드 활성화 예제
- [명령어 참조](commands.md) - 명령어가 자동으로 모드 활성화
- [설치 가이드](../Getting-Started/installation.md) - 행동 모드 설정

**🌿 중급 (2-3주차)**
- [에이전트 가이드](agents.md) - 모드가 전문가와 조정하는 방법
- [플래그 가이드](flags.md) - 수동 모드 제어 및 최적화
- [예제 모음](../Reference/examples-cookbook.md) - 실제 모드 패턴

**🌲 고급 (2개월 이상)**
- [MCP 서버](mcp-servers.md) - 향상된 기능과의 모드 통합
- [세션 관리](session-management.md) - 작업 관리 모드 워크플로우
- [시작하기](../Getting-Started/quick-start.md) - 모드 사용 패턴

**🔧 전문가**
- [기술 아키텍처](../Developer-Guide/technical-architecture.md) - 모드 구현 세부사항
- [코드 기여](../Developer-Guide/contributing-code.md) - 모드 기능 확장

**모드별 가이드:**
- **브레인스토밍**: [요구사항 발견 패턴](../Reference/examples-cookbook.md#requirements)
- **작업 관리**: [세션 관리 가이드](session-management.md)
- **오케스트레이션**: [MCP 서버 가이드](mcp-servers.md)
- **토큰 효율성**: [명령어 기본사항](commands.md#token-efficiency)

