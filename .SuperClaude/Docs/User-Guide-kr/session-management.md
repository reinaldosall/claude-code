# 세션 관리 가이드

SuperClaude는 Serena MCP 서버를 통해 영구 세션 관리를 제공하여 Claude Code 대화 전반에 걸쳐 진정한 컨텍스트 보존과 장기 프로젝트 연속성을 가능하게 합니다.

## 영구 메모리를 사용한 핵심 세션 명령어

### `/sc:load` - 영구 메모리를 사용한 컨텍스트 로딩
**목적**: 이전 세션의 프로젝트 컨텍스트 및 영구 메모리로 세션 초기화
**MCP 통합**: Serena MCP가 저장된 프로젝트 메모리를 읽도록 트리거
**구문**: `/sc:load [프로젝트_경로]`

**발생하는 일**:
- Serena MCP가 이전 세션의 영구 메모리 파일 읽기
- 저장된 메모리에서 프로젝트 컨텍스트 복원
- 이전 결정, 패턴, 진행 상황 로드
- 과거 컨텍스트로 세션 상태 초기화

**사용 사례**:
```bash
# 영구 메모리에서 기존 프로젝트 컨텍스트 로드
/sc:load src/

# 전체 기록과 함께 특정 프로젝트 작업 재개
/sc:load "authentication-system"

# 코드베이스 분석 및 이전 통찰력으로 초기화
/sc:load . --analyze
```

### `/sc:save` - 메모리에 세션 지속성
**목적**: 현재 세션 상태 및 결정을 영구 메모리에 저장
**MCP 통합**: Serena MCP가 메모리 파일을 작성하도록 트리거
**구문**: `/sc:save "세션_설명"`

**발생하는 일**:
- 현재 컨텍스트 및 결정이 Serena 메모리에 작성됨
- 프로젝트 상태 및 진행 상황이 대화 전반에 걸쳐 지속됨
- 주요 통찰력 및 패턴이 향후 세션을 위해 저장됨
- 검색을 위한 타임스탬프와 함께 세션 요약 생성

**사용 사례**:
```bash
# 향후 참조를 위해 완료된 기능 작업 저장
/sc:save "JWT로 사용자 인증 구현됨"

# 복잡한 작업 중 체크포인트
/sc:save "API 설계 단계 완료, 구현 준비"

# 아키텍처 결정을 영구적으로 저장
/sc:save "마이크로서비스 아키텍처 결정, 서비스 경계 정의됨"
```

### `/sc:reflect` - 메모리 컨텍스트를 사용한 진행 상황 평가
**목적**: 저장된 메모리에 대한 현재 진행 상황 분석 및 세션 완전성 검증
**MCP 통합**: Serena MCP를 사용하여 저장된 메모리에 대한 현재 상태 비교
**구문**: `/sc:reflect [--scope project|session]`

**발생하는 일**:
- Serena MCP가 이전 메모리 및 현재 컨텍스트 읽기
- 저장된 목표 및 마일스톤에 대한 진행 상황 평가
- 과거 컨텍스트를 사용하여 격차 및 다음 단계 식별
- 프로젝트 메모리에 대한 세션 완전성 검증

**사용 사례**:
```bash
# 저장된 마일스톤에 대한 프로젝트 진행 상황 평가
/sc:reflect --scope project

# 현재 세션 완전성 검증
/sc:reflect

# 메모리를 기반으로 다음 단계로 이동할 준비가 되었는지 확인
/sc:reflect --scope session
```

## 영구 메모리 아키텍처

### Serena MCP가 진정한 지속성을 가능하게 하는 방법

**메모리 저장**:
- 구조화된 메모리 파일로 저장된 세션 컨텍스트
- 영구적으로 보존된 프로젝트 결정 및 아키텍처 패턴
- 대화 전반에 걸쳐 유지되는 코드 분석 결과 및 통찰력
- 장기적으로 유지되는 진행 상황 추적 및 마일스톤 데이터

**교차 세션 연속성**:
- 새 대화에서 자동으로 사용 가능한 이전 세션 컨텍스트
- 대화 전반에 걸쳐 보존되고 액세스 가능한 결정 및 근거
- 과거 패턴 및 솔루션으로부터의 학습 유지
- 무기한 유지되는 일관된 프로젝트 이해

**메모리 유형**:
- **프로젝트 메모리**: 장기 프로젝트 컨텍스트 및 아키텍처
- **세션 메모리**: 특정 대화 결과 및 결정
- **패턴 메모리**: 재사용 가능한 솔루션 및 아키텍처 패턴
- **진행 메모리**: 마일스톤 추적 및 완료 상태

## 지속성을 갖춘 세션 라이프사이클 패턴

### 새 프로젝트 초기화
```bash
# 1. 새 프로젝트 시작
/sc:brainstorm "전자상거래 플랫폼 요구사항"

# 2. 초기 결정을 영구 메모리에 저장
/sc:save "프로젝트 범위 및 요구사항 정의됨"

# 3. 구현 계획 시작
/sc:workflow "사용자 인증 시스템"

# 4. 아키텍처 결정을 영구적으로 저장
/sc:save "인증 아키텍처: JWT + 리프레시 토큰 + 속도 제한"
```

### 기존 작업 재개 (교차 대화)
```bash
# 1. 영구 메모리에서 이전 컨텍스트 로드
/sc:load "e-commerce-project"

# 2. 저장된 진행 상황에 대한 현재 상태 평가
/sc:reflect --scope project

# 3. 저장된 컨텍스트를 사용하여 다음 단계 계속
/sc:implement "결제 처리 통합"

# 4. 진행 상황 체크포인트를 메모리에 저장
/sc:save "Stripe API와 결제 시스템 통합됨"
```

### 장기 프로젝트 관리
```bash
# 지속성을 갖춘 주간 체크포인트 패턴
/sc:load project-name
/sc:reflect --scope project
# ... 기능 작업 ...
/sc:save "N주차 진행: 기능 X, Y, Z 완료"

# 메모리를 사용한 단계 완료 패턴
/sc:reflect --scope project
/sc:save "1단계 완료: 핵심 인증 및 사용자 관리"
/sc:workflow "2단계: 결제 및 주문 처리"
```

## 교차 대화 연속성

### 지속성을 갖춘 새 대화 시작

새 Claude Code 대화를 시작할 때 영구 메모리 시스템이 다음을 허용합니다:

1. **자동 컨텍스트 복원**
   ```bash
   /sc:load project-name
   # 모든 이전 컨텍스트, 결정, 진행 상황을 자동으로 복원
   ```

2. **진행 계속**
   - 이전 세션 결정을 즉시 사용 가능
   - 아키텍처 패턴 및 코드 통찰력 보존
   - 프로젝트 기록 및 근거 유지

3. **지능형 컨텍스트 구축**
   - Serena MCP가 현재 작업에 기반하여 관련 메모리 제공
   - 과거 솔루션 및 패턴이 새 구현 정보 제공
   - 프로젝트 진화 추적 및 이해

### 메모리 최적화

**효과적인 메모리 사용**:
- 설명적이고 검색 가능한 메모리 이름 사용
- 프로젝트 단계 및 타임스탬프 컨텍스트 포함
- 특정 기능 또는 아키텍처 결정 참조
- 향후 검색을 직관적으로 만들기

**메모리 콘텐츠 전략**:
- 결과뿐만 아니라 결정 및 근거 저장
- 고려된 대안 접근법 포함
- 통합 패턴 및 종속성 문서화
- 향후 참조를 위한 학습 및 통찰력 보존

**메모리 라이프사이클 관리**:
- 오래된 메모리의 정기적인 정리
- 관련 세션 메모리 통합
- 완료된 프로젝트 단계 아카이빙
- 쓸모없는 아키텍처 결정 정리

## 영구 세션 모범 사례

### 세션 시작 프로토콜
1. 기존 프로젝트의 경우 항상 `/sc:load`로 시작
2. `/sc:reflect`를 사용하여 메모리에서 현재 상태 이해
3. 영구 컨텍스트 및 저장된 패턴을 기반으로 작업 계획
4. 이전 결정 및 아키텍처 선택 기반 구축

### 세션 종료 프로토콜
1. `/sc:reflect`를 사용하여 저장된 목표에 대한 완전성 평가
2. 향후 세션을 위해 `/sc:save`로 주요 결정 저장
3. 메모리에 다음 단계 및 미해결 질문 문서화
4. 원활한 향후 계속을 위한 컨텍스트 보존

### 메모리 품질 유지
- 쉬운 검색을 위해 명확하고 설명적인 메모리 이름 사용
- 결정 및 대안 접근법에 대한 컨텍스트 포함
- 특정 코드 위치 및 패턴 참조
- 세션 전반에 걸쳐 메모리 구조의 일관성 유지

## 다른 SuperClaude 기능과의 통합

### MCP 서버 조정
- **Serena MCP**: 영구 메모리 인프라 제공
- **Sequential MCP**: 향상된 복잡한 분석을 위해 저장된 메모리 사용
- **Context7 MCP**: 저장된 패턴 및 문서화 접근법 참조
- **Morphllm MCP**: 저장된 리팩토링 패턴을 일관되게 적용

### 메모리를 사용한 에이전트 협업
- 에이전트가 향상된 컨텍스트를 위해 영구 메모리 액세스
- 이전 전문가 결정이 보존되고 참조됨
- 공유 메모리를 통한 교차 세션 에이전트 조정
- 프로젝트 기록을 기반으로 한 일관된 전문가 권장사항

### 지속성을 갖춘 명령어 통합
- 모든 `/sc:` 명령어가 영구 컨텍스트를 참조하고 구축 가능
- 이전 명령어 출력 및 결정이 세션 전반에 걸쳐 사용 가능
- 워크플로우 패턴이 저장되고 재사용 가능
- 구현 기록이 향후 명령어 결정 안내

## 영구 세션 문제 해결

### 일반적인 문제

**메모리 로딩 안 됨**:
- Serena MCP가 올바르게 구성되고 실행 중인지 확인
- 메모리 파일 권한 및 접근성 확인
- 일관된 프로젝트 명명 규칙 보장
- 메모리 파일 무결성 및 형식 검증

**세션 간 컨텍스트 손실**:
- 세션을 종료하기 전에 항상 `/sc:save` 사용
- 쉬운 검색을 위해 설명적인 메모리 이름 사용
- 메모리 완전성을 검증하기 위한 정기적인 `/sc:reflect`
- 중요한 메모리 파일을 주기적으로 백업

**메모리 충돌**:
- 버전 제어를 위해 타임스탬프가 있는 메모리 이름 사용
- 오래된 메모리의 정기적인 정리
- 프로젝트 및 세션 메모리 간의 명확한 분리
- 세션 전반에 걸쳐 일관된 메모리 명명 규칙

### 빠른 수정

**세션 상태 재설정**:
```bash
/sc:load --fresh  # 이전 컨텍스트 없이 시작
/sc:reflect       # 현재 상태 평가
```

**메모리 정리**:
```bash
/sc:reflect --cleanup  # 오래된 메모리 제거
/sc:save --consolidate # 관련 메모리 병합
```

**컨텍스트 복구**:
```bash
/sc:load --recent     # 최근 메모리 로드
/sc:reflect --repair  # 컨텍스트 격차 식별 및 수정
```

## 고급 영구 세션 패턴

### 다단계 프로젝트
- 조직을 위한 단계별 메모리 명명 사용
- 단계 전반에 걸쳐 아키텍처 결정 연속성 유지
- 영구 메모리를 통한 교차 단계 종속성 추적
- 과거 컨텍스트를 사용한 점진적 복잡성 관리

### 팀 협업
- 공유 메모리 규칙 및 명명 표준
- 팀 컨텍스트를 위한 결정 근거 보존
- 모든 팀원이 액세스 가능한 통합 패턴 문서
- 메모리를 통한 일관된 코드 스타일 및 아키텍처 강제

### 장기 유지보수
- 완료된 프로젝트를 위한 메모리 아카이빙 전략
- 누적된 메모리를 통한 패턴 라이브러리 개발
- 시간이 지남에 따라 구축된 재사용 가능한 솔루션 문서
- 영구 메모리 축적을 통한 지식 베이스 구축

## 영구 세션 관리의 주요 이점

### 프로젝트 연속성
- 여러 대화에 걸쳐 원활한 작업 계속
- Claude Code 세션 간 컨텍스트 손실 없음
- 보존된 아키텍처 결정 및 기술 근거
- 장기 프로젝트 진화 추적

### 향상된 생산성
- 프로젝트 컨텍스트를 다시 설명할 필요 감소
- 계속 작업을 위한 더 빠른 시작 시간
- 이전 통찰력 및 패턴 기반 구축
- 누적 프로젝트 지식 성장

### 품질 일관성
- 세션 전반에 걸쳐 일관된 아키텍처 패턴
- 보존된 코드 품질 결정 및 표준
- 재사용 가능한 솔루션 및 모범 사례
- 유지된 기술 부채 인식

---

**핵심 요점**: Serena MCP를 통한 세션 관리는 SuperClaude를 단일 대화 지원에서 영구 프로젝트 파트너십으로 변환하여 모든 개발 단계 및 Claude Code 대화 전반에 걸쳐 컨텍스트, 결정, 학습을 유지합니다.

